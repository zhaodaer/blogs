(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{454:function(s,a,t){"use strict";t.r(a);var e=t(2),n=Object(e.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[a("strong",[s._v("1、字符设备驱动")])]),s._v(" "),a("hr"),s._v(" "),a("p",[s._v("字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的点灯、按键、IIC、SPI，LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动。")]),s._v(" "),a("p",[s._v("编写时用到了Linux内核，故应该先将之前编译好的内核放入指定文件夹")]),s._v(" "),a("p",[s._v("Linux驱动开发并不是直接去操作寄存器，而是进行各种驱动框架的开发")]),s._v(" "),a("p",[s._v("设备树：将设备的信息写到设备树里，Linux内核就会分析该设备树。。。。。。。")]),s._v(" "),a("p",[s._v("Linux操作系统内核和驱动程序运行在内核空间、应用程序运行在用户空间，而在单片机中驱动和应用是杂糅在一起的。之所以分开，是因为考虑其安全性，防止不正当的操作影响了底层操作系统。")]),s._v(" "),a("p",[s._v("Linux下一切皆文件，驱动设备最终表现为dev/下的某文件。如dev/led，应用程序通过对这个名为“/dev/led的文件进行相应的操作即可实现对硬件的操作。")]),s._v(" "),a("p",[s._v("在Linux内核里，printf()—>printk()")]),s._v(" "),a("hr"),s._v(" "),a("p",[a("strong",[s._v("应用程序怎样访问内核资源？")])]),s._v(" "),a("p",[s._v("​\t\t通过"),a("u",[s._v("系统调用、异常（中断）和陷入")]),s._v("三种方法。")]),s._v(" "),a("p",[s._v("​\t\t其中==系统调用==：应用程序不会直接调用系统调用，而是通过API函数来间接的调用系统调用,比如POSIX、API和C库等。unix 类操作系统中最常用的编程接口就是POSIX。")]),s._v(" "),a("p",[s._v("​\t\t系统调用处于内核空间，应用程序无法直接访问，因此需要“陷入“到内核,方法就是软中断。陷入内核以后还要指定系统调用号。\t每个系统调用都有一个系统调用号。。")]),s._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"C:/Users/%E4%B8%9C%E7%91%9E/AppData/Roaming/Typora/typora-user-images/image-20231130210741153.png",alt:"image-20231130210741153"}}),s._v(" "),a("hr"),s._v(" "),a("p",[a("strong",[s._v("第一个字符驱动设备框架的编写")])]),s._v(" "),a("div",{staticClass:"language-C line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("include")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("<linux/module.h>")]),s._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//用到了Linux内核里的函数")])]),s._v("\n\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" __init "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("chrdevbase_init")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" __exit "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("chrdevbase_exit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* \n * 将上面两个函数指定为驱动的入口和出口函数 \n */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("module_init")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("chrdevbase_init"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("module_exit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("chrdevbase_exit"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br")])]),a("hr"),s._v(" "),a("p",[a("strong",[s._v("驱动模块的加载和卸载:")])]),s._v(" "),a("p",[s._v("Linux 驱动有两种运行方式")]),s._v(" "),a("p",[s._v("1、将驱动*"),a("u",[s._v("==编译进 Linux 内核==")]),s._v("*中，当 Linux 内核启动的时候就会自动运行驱动程序。")]),s._v(" "),a("p",[s._v("2、将驱动"),a("u",[a("em",[s._v("==编译成模块==")])]),s._v("(Linux 下模块扩展名为.ko)，在Linux 内核启动以后使用“insmod”命令加载驱动模块。")]),s._v(" "),a("p",[s._v("在调试驱动的时候一般都选择将其编译为模块，这样我们修改驱动以后只需要编译一下驱动代码即可，不需要编译整个 Linux 代码。而且在调试的时候只需要加载或者卸载驱动模块即可，不需要重启整个系统。")]),s._v(" "),a("p",[s._v("优点：方便开发，当驱动开发完成，确定没有问题以后就可以将驱动编译进Linux 内核中")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("module_init")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("xxx_init"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//注册模块加载函数")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("module_exit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("xxx_exit"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//注册模块卸载函数")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("当使用“insmod”命令加载驱动的时候，xxx_init 这个函数就会被调用，向 Linux 内核注册一个模块加载函数。")]),s._v(" "),a("p",[s._v("当使用“rmmod”命令卸载具体驱动的时候 xxx_exit 函数就会被调用，向 Linux 内核注册一个模块卸载函数。")]),s._v(" "),a("hr"),s._v(" "),a("p",[a("strong",[s._v("字符设备的注册与注销：")])]),s._v(" "),a("p",[s._v("当驱动模块加载成功以后需要注册字符设备，同样，卸载驱动模块的时候也需要注销掉字符设备。")]),s._v(" "),a("p",[s._v("一般字符设备的注册在驱动模块的入口函数 xxx_init 中进行，字符设备的注销在驱动模块的出口函数 xxx_exit 中进行")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//注册函数")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("register_chrdev")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("unsigned")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" major"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("char")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("file_operations")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("fops"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//注销函数")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("unregister_chrdev")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("unsigned")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" major"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("char")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("hr"),s._v(" "),a("p",[a("strong",[s._v("设备号：")])]),s._v(" "),a("p",[s._v("Linux 中每个设备都有一个设备号，设备号由主设备号和次设备号两部分组成。")]),s._v(" "),a("p",[s._v("主设备号表示某一个具体的驱动，次设备号表示使用这个驱动的各个设备。")]),s._v(" "),a("p",[s._v("查看当前系统里都用了哪些设备号：")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[s._v("cat "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("proc"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("devices\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("hr"),s._v(" "),a("p",[a("strong",[s._v("应用程序编写测试：")])]),s._v(" "),a("p",[s._v("编写完应用程序后，因为测试 APP 是要在 ARM 开发板上运行的，所以要进行交叉编译，将chedevbaseAPP.c编译成chedevbaseAPP应用程序。")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[s._v("arm"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("linux"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("gnueabihf"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("gcc chrdevbaseApp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("c "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("o chrdevbaseApp\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("再和之前写好的驱动文件一同拷贝到同一文件下，去运行")]),s._v(" "),a("p",[a("img",{attrs:{src:"C:/Users/%E4%B8%9C%E7%91%9E/AppData/Roaming/Typora/typora-user-images/image-20231202185405618.png",alt:"image-20231202185405618"}})]),s._v(" "),a("hr"),s._v(" "),a("p",[a("strong",[s._v("具体测试步骤：")])]),s._v(" "),a("p",[s._v("首先保证在开发板的某目录下（比如 /lib/modules/4.1.15）存在了chrdevbase.ko和chrdevbaseAPP这两个文件")]),s._v(" "),a("p",[a("strong",[s._v("(1) 加载驱动模块")])]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[s._v("modprobe chrdevbase"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("ko\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("输入命令后显示")]),s._v(" "),a("p",[a("img",{attrs:{src:"C:/Users/%E4%B8%9C%E7%91%9E/AppData/Roaming/Typora/typora-user-images/image-20231202190640879.png",alt:"image-20231202190640879"}})]),s._v(" "),a("p",[s._v("输入“lsmod”命令查看当前系统中存在的模块")]),s._v(" "),a("p",[a("img",{attrs:{src:"C:/Users/%E4%B8%9C%E7%91%9E/AppData/Roaming/Typora/typora-user-images/image-20231202190725208.png",alt:"image-20231202190725208"}})]),s._v(" "),a("p",[s._v("输入如下命令查看当前系统中有没有 chrdevbase 这个设备：")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[s._v("cat "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("proc"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("devices\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[a("strong",[s._v("(2) 创建设备节点文件")])]),s._v(" "),a("p",[s._v("驱动加载成功需要在/dev 目录下创建一个与之对应的设备节点文件，应用程序就是通过操\n作这个设备节点文件来完成对具体设备的操作。")]),s._v(" "),a("p",[s._v("输入如下命令创建/dev/chrdevbase 这个设备节点文件：")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[s._v("mknod "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("dev"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("chrdevbase c "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("200")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("创建完成以后就会存在/dev/chrdevbase 这个文件，")]),s._v(" "),a("p",[s._v("使用“ls /dev/chrdevbase -l”命令查看")]),s._v(" "),a("p",[a("strong",[s._v("(3) chrdevbase 设备操作测试")])]),s._v(" "),a("p",[s._v("输入命令：")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("chrdevbaseApp "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("dev"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("chrdevbase "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[a("strong",[s._v("（4）卸载驱动模块")]),s._v("\n如果不再使用某个设备的话可以将其驱动卸载掉")]),s._v(" "),a("p",[s._v("输入命令：")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[s._v("rmmod chrdevbase"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("ko\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("卸载以后使用 lsmod 命令查看 chrdevbase 这个模块还存不存在")]),s._v(" "),a("p",[a("img",{attrs:{src:"C:/Users/%E4%B8%9C%E7%91%9E/AppData/Roaming/Typora/typora-user-images/image-20231202191310139.png",alt:"image-20231202191310139"}})]),s._v(" "),a("hr"),s._v(" "),a("hr"),s._v(" "),a("h4",{attrs:{id:"编写步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编写步骤"}},[s._v("#")]),s._v(" 编写步骤")]),s._v(" "),a("p",[s._v("① 确定主设备号，也可以让内核分配")]),s._v(" "),a("p",[s._v("② 定义自己的 file_operations 结构体")]),s._v(" "),a("p",[s._v("③ 实现对应的 drv_open/ drv_read/ drv_write 等函数，填入 file_operations 结构体")]),s._v(" "),a("p",[s._v("④ 把 file_operations 结构体告诉内核：register_chrdev")]),s._v(" "),a("p",[s._v("⑤ 谁来注册驱动程序？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数")]),s._v(" "),a("p",[s._v("⑥ 有入口函数就应该有出口函数：卸载驱动程序时，出口函数调用 unregister_chrdev")]),s._v(" "),a("p",[s._v("⑦ 其他完善：提供设备信息，自动创建设备节点：class_create, device_create")]),s._v(" "),a("h4",{attrs:{id:"文件句柄"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件句柄"}},[s._v("#")]),s._v(" 文件句柄")]),s._v(" "),a("p",[s._v("文件句柄是一个抽象的概念，它用于在编程中表示对特定文件的访问。在许多编程语言中，当你打开一个文件以进行读取、写入或其他操作时，你会被分配一个文件句柄。这个文件句柄就像一个钥匙，允许你通过它来访问和操作文件。")]),s._v(" "),a("p",[s._v("文件句柄的本质是一个整数或一个代表特定文件打开实例的标识符。当你打开一个文件时，操作系统会为该文件返回一个唯一的文件句柄。你可以使用这个文件句柄来读取或写入文件，甚至可以在程序的不同部分之间传递它，以便对同一个文件进行共享访问。")]),s._v(" "),a("p",[s._v("文件句柄在处理文件I/O（输入/输出）时非常重要。通过文件句柄，你可以有效地控制对文件的访问，例如掌握读取或写入数据的速度，或者在不同的线程之间协调对同一个文件的访问。在某些情况下，当需要对大量数据进行处理时，文件句柄也用于缓存数据的读取和写入，以提高程序的性能。")]),s._v(" "),a("p",[s._v("需要注意的是，一旦关闭了与文件句柄关联的文件，该文件句柄就会失效，不能再用于访问该文件。再次访问该文件需要重新打开并获取新的文件句柄。")])])}),[],!1,null,null,null);a.default=n.exports}}]);